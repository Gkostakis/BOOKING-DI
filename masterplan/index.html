<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MASTERPLAN — Network Diagram</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --font: 'Space Mono', 'Courier New', monospace;
    --bg: #141414;
    --canvas-bg: #0d0f14;
    --toolbar-bg: #1C1C1C;
    --toolbar-border: #2A2A2A;
    --text: #E8E8E8;
    --muted: #666;
    --accent: #52B788;
    --accent-light: #74C69D;
    --modal-bg: #1C1C1C;
    --shadow: 0 2px 20px rgba(0,0,0,0.5);
    --shadow-node: 0 4px 16px rgba(0,0,0,0.4);
    --radius: 10px;
  }

  body {
    font-family: var(--font);
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    font-size: 13px;
  }

  /* ── TOOLBAR ── */
  #toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 16px;
    background: var(--toolbar-bg);
    border-bottom: 1px solid var(--toolbar-border);
    flex-shrink: 0;
    flex-wrap: wrap;
    z-index: 100;
  }

  #toolbar .brand {
    font-size: 18px;
    font-weight: 800;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: #99B8B3;
    margin-right: 8px;
    white-space: nowrap;
  }

  #toolbar .sep {
    width: 1px;
    height: 24px;
    background: #333;
    margin: 0 4px;
  }

  .btn {
    font-family: var(--font);
    font-size: 11px;
    font-weight: 700;
    letter-spacing: 0.5px;
    text-transform: uppercase;
    padding: 6px 14px;
    border-radius: 4px;
    border: none;
    background: #2A2A2A;
    color: #CCCCCC;
    cursor: pointer;
    transition: background 0.12s ease, color 0.12s ease;
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
    gap: 5px;
  }
  .btn:hover { background: #333333; color: #FFFFFF; }
  .btn:active { background: #3A3A3A; }
  .btn-icon {
    width: 30px;
    height: 30px;
    padding: 0;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }
  #bg-color-wrap {
    position: relative;
    display: inline-flex;
  }
  #bg-color-input {
    position: absolute;
    inset: 0;
    opacity: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
    border: none;
    padding: 0;
  }
  /* Small canvas-color swatch shown inside the button */
  #bg-color-swatch {
    width: 10px;
    height: 10px;
    border-radius: 2px;
    border: 1px solid rgba(255,255,255,0.25);
    background: #0d0f14;
    position: absolute;
    bottom: 5px;
    right: 5px;
    pointer-events: none;
    transition: background 0.15s;
  }
  .btn.primary { background: #2A2A2A; color: #FFFFFF; }
  .btn.primary:hover { background: #383838; }
  .btn.danger { background: #2A2A2A; color: #E07070; }
  .btn.danger:hover { background: #332020; color: #FF8888; }

  #search-wrap {
    position: relative;
    margin-left: auto;
  }
  #search {
    font-family: var(--font);
    font-size: 11px;
    letter-spacing: 0.3px;
    padding: 6px 12px 6px 32px;
    border: 1px solid #333;
    border-radius: 4px;
    outline: none;
    width: 33vw;
    background: #222;
    color: #CCC;
    transition: border 0.15s;
  }
  #search:focus { border-color: var(--accent-light); }
  #search::placeholder { color: #555; }
  #search-wrap::before {
    content: '⌕';
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--muted);
    font-size: 15px;
    pointer-events: none;
  }

  /* ── SVG CANVAS ── */
  #canvas-wrap {
    flex: 1;
    overflow: hidden;
    position: relative;
  }
  svg#graph {
    width: 100%;
    height: 100%;
    background: var(--canvas-bg);
    cursor: grab;
  }
  svg#graph:active { cursor: grabbing; }

  .node-group { cursor: pointer; }
  /* node-circle class is reused for both circle and rect elements */
  .node-circle {
    transition: opacity 0.2s ease;
  }
  .node-group.highlighted .node-circle {
    filter: url(#glow-bright);
  }
  .node-group.dimmed .node-circle { opacity: 0.08 !important; }
  .node-group.dimmed .node-label  { opacity: 0.08 !important; }
  .node-label {
    font-family: var(--font);
    font-weight: 600;
    fill: #FFFFFF;
    pointer-events: none;
    text-anchor: middle;
    dominant-baseline: auto;
    letter-spacing: 0px;
  }
  .node-label-wrap {
    pointer-events: none;
  }

  .link-path {
    fill: none;
    stroke-linecap: round;
    transition: opacity 0.3s;
  }
  .link-path.dimmed { opacity: 0.12; }
  .node-group.dimmed .node-circle { opacity: 0.15; }
  .node-group.dimmed .node-label { opacity: 0.15; }

  /* ── TOOLTIP ── */
  #tooltip {
    position: fixed;
    background: rgba(10,10,10,0.66);
    color: #E8E8E8;
    font-family: var(--font);
    font-size: 12px;
    padding: 8px 12px;
    border-radius: 8px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s;
    z-index: 9999;
    max-width: 220px;
    line-height: 1.6;
  }
  #tooltip.show { opacity: 1; }
  #tooltip strong { font-size: 13px; display: block; margin-bottom: 2px; }

  /* ── MODAL ── */
  #modal-overlay {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.3);
    backdrop-filter: blur(4px);
    z-index: 1000;
    display: none;
    align-items: center;
    justify-content: center;
  }
  #modal-overlay.show { display: flex; }

  #modal {
    background: var(--modal-bg);
    border: 1px solid #2E2E2E;
    border-radius: var(--radius);
    box-shadow: 0 24px 60px rgba(0,0,0,0.7);
    width: 480px;
    max-width: 95vw;
    max-height: 88vh;
    overflow-y: auto;
    padding: 28px;
    position: relative;
    animation: modalIn 0.25s cubic-bezier(0.34,1.56,0.64,1);
  }
  @keyframes modalIn {
    from { transform: scale(0.88) translateY(20px); opacity: 0; }
    to   { transform: scale(1) translateY(0); opacity: 1; }
  }

  #modal h2 {
    font-size: 16px;
    font-weight: 700;
    margin-bottom: 20px;
    color: var(--text);
    letter-spacing: -0.3px;
  }
  #modal-close {
    position: absolute;
    top: 16px; right: 16px;
    background: #2A2A2A;
    border: none;
    border-radius: 50%;
    width: 28px; height: 28px;
    font-size: 16px;
    cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    color: #666;
    transition: background 0.15s;
  }
  #modal-close:hover { background: #383838; color: #CCC; }

  .field-group {
    margin-bottom: 16px;
  }
  .field-group label {
    display: block;
    font-size: 12px;
    font-weight: 600;
    color: #555;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    margin-bottom: 5px;
  }
  .field-group input[type="text"],
  .field-group input[type="number"],
  .field-group textarea,
  .field-group select {
    font-family: var(--font);
    font-size: 12px;
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #2E2E2E;
    border-radius: 6px;
    outline: none;
    background: #141414;
    transition: border 0.15s;
    color: var(--text);
  }
  .field-group input:focus,
  .field-group textarea:focus,
  .field-group select:focus { border-color: var(--accent-light); background: #1A1A1A; }
  .field-group input[type="range"] { width: 100%; accent-color: var(--accent); }
  .field-group input[type="color"] {
    width: 48px; height: 36px;
    border-radius: 8px;
    border: 1px solid #2A2A2A;
    padding: 2px;
    cursor: pointer;
    background: white;
  }

  .range-row { display: flex; align-items: center; gap: 10px; }
  .range-val {
    font-size: 13px;
    font-weight: 700;
    color: var(--accent);
    min-width: 18px;
    text-align: center;
  }

  .color-row { display: flex; align-items: center; gap: 10px; }
  .color-presets {
    display: flex; gap: 5px; flex-wrap: nowrap;
  }
  .color-preset {
    width: 20px; height: 20px;
    border-radius: 50%;
    cursor: pointer;
    flex-shrink: 0;
    border: 2px solid transparent;
    transition: border 0.15s, transform 0.15s;
  }
  .color-preset:hover { transform: scale(1.2); border-color: #999; }

  .link-select {
    font-family: var(--font);
    font-size: 12px;
    width: 100%;
    min-height: 80px;
    padding: 6px;
    border: 1px solid #2E2E2E;
    border-radius: 6px;
    background: #141414;
    color: var(--text);
    outline: none;
  }
  .link-select:focus { border-color: var(--accent-light); }

  #custom-props-list { margin-top: 6px; }
  .custom-prop-row {
    display: flex; gap: 6px; align-items: center; margin-bottom: 6px;
  }
  .custom-prop-row input { flex: 1; }
  .custom-prop-row .rm-prop {
    background: none; border: none; color: #C0392B; cursor: pointer;
    font-size: 16px; padding: 0 4px;
    transition: transform 0.15s;
  }
  .custom-prop-row .rm-prop:hover { transform: scale(1.2); }

  .modal-actions {
    display: flex; gap: 8px; margin-top: 20px; justify-content: flex-end;
  }

  /* ── EXPORT PANEL ── */
  #export-wrap {
    position: relative;
    display: inline-flex;
  }
  #export-panel {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    background: #1E1E1E;
    border: 1px solid #2E2E2E;
    border-radius: 6px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    padding: 4px;
    z-index: 500;
    display: none;
    flex-direction: column;
    gap: 2px;
    min-width: 148px;
    animation: modalIn 0.15s cubic-bezier(0.34,1.56,0.64,1);
  }
  #export-panel.show { display: flex; }
  #export-panel .btn {
    justify-content: flex-start;
    font-size: 11px;
    padding: 7px 12px;
    border-radius: 4px;
    width: 100%;
    text-align: left;
  }

  /* ── ZOOM TO FIT ── */
  #btn-zoom-fit {
    position: absolute;
    bottom: 20px;
    left: 20px;
    z-index: 50;
    width: 36px;
    height: 36px;
    border-radius: 6px;
    border: 1px solid #2A2A2A;
    background: rgba(13,15,20,0.85);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 1px 6px rgba(0,0,0,0.4);
    transition: background 0.12s, border-color 0.12s, box-shadow 0.12s;
    padding: 0;
  }
  #btn-zoom-fit:hover {
    background: rgba(30,35,45,0.95);
    border-color: #444;
    box-shadow: 0 2px 10px rgba(0,0,0,0.14);
  }
  #btn-zoom-fit:active { background: #EBEBEB; }
  #btn-zoom-fit svg { display: block; }

  /* ── EMPTY STATE ── */
  #empty-hint {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: #333;
    pointer-events: none;
    transition: opacity 0.4s;
  }
  #empty-hint .big { font-size: 48px; margin-bottom: 12px; }
  #empty-hint p { font-size: 14px; line-height: 1.6; }
  #empty-hint strong { color: #555; }

  /* ── STATUS BAR ── */
  #statusbar {
    padding: 4px 16px;
    font-size: 11px;
    color: var(--muted);
    background: var(--toolbar-bg);
    border-top: 1px solid var(--toolbar-border);
    display: flex;
    gap: 16px;
    flex-shrink: 0;
    align-items: center;
    font-size: 10px;
    letter-spacing: 0.3px;
  }

  /* ── FOOTER ── */
  #footer {
    padding: 5px 16px;
    font-size: 10px;
    color: #444444;
    background: var(--toolbar-bg);
    border-top: 1px solid var(--toolbar-border);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
    letter-spacing: 0.2px;
  }
  #footer .footer-left { font-style: italic; }
  #footer .footer-right { font-weight: 500; }
  #footer .footer-version { color: #666; letter-spacing: 0.5px; }

  /* ── OVERLAY PANEL ── */
  #overlay-panel {
    position: absolute;
    top: 0;
    right: 0;
    width: 33vw;
    height: 100%;
    background: rgba(13, 15, 20, 0.55);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-left: 1px solid rgba(255,255,255,0.07);
    z-index: 40;
    display: flex;
    flex-direction: column;
    padding: 20px 0 20px 0;
    pointer-events: none;
    opacity: 0;
    transform: translateX(12px);
    transition: opacity 0.3s ease, transform 0.3s ease;
  }
  #overlay-panel.visible {
    opacity: 1;
    transform: translateX(0);
    pointer-events: auto;
  }
  #overlay-header {
    padding: 0 20px 12px 20px;
    border-bottom: 1px solid rgba(255,255,255,0.07);
    margin-bottom: 4px;
    display: flex;
    align-items: baseline;
    justify-content: space-between;
  }
  #overlay-header span {
    font-family: var(--font);
    font-size: 9px;
    font-weight: 700;
    letter-spacing: 1.2px;
    text-transform: uppercase;
    color: #AAAAAA;
  }
  #overlay-header .col-labels {
    display: flex;
    gap: 14px;
  }
  #overlay-list {
    flex: 1;
    overflow-y: auto;
    padding: 4px 0;
  }
  .overlay-row {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 7px 20px;
    transition: background 0.12s;
    cursor: pointer;
  }
  .overlay-row:hover { background: rgba(255,255,255,0.05); }
  .overlay-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  .overlay-name {
    font-family: var(--font);
    font-size: 11px;
    color: #CCCCCC;
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    letter-spacing: 0.1px;
  }
  .overlay-imp {
    font-family: var(--font);
    font-size: 10px;
    font-weight: 700;
    color: #74C69D;
    min-width: 14px;
    text-align: right;
  }
  .overlay-conn {
    font-family: var(--font);
    font-size: 10px;
    color: #666;
    min-width: 22px;
    text-align: right;
  }
  #btn-overlay-toggle {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    z-index: 41;
    width: 20px;
    height: 48px;
    background: rgba(13,15,20,0.85);
    border: 1px solid rgba(0,0,0,0.08);
    border-right: none;
    border-radius: 6px 0 0 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: -2px 0 8px rgba(0,0,0,0.06);
    transition: background 0.12s;
    padding: 0;
  }
  #btn-overlay-toggle:hover { background: rgba(30,35,45,0.95); }
  #btn-overlay-toggle svg { display: block; }

  /* SCROLLBAR */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }

  /* ── NOTIFICATION ── */
  #notif {
    position: fixed;
    bottom: 24px; left: 50%;
    transform: translateX(-50%) translateY(80px);
    background: #2A2A2A;
    color: #E8E8E8;
    font-family: var(--font);
    font-size: 13px;
    padding: 10px 20px;
    border-radius: 24px;
    z-index: 9999;
    transition: transform 0.3s cubic-bezier(0.34,1.56,0.64,1), opacity 0.3s;
    opacity: 0;
    pointer-events: none;
  }
  #notif.show { transform: translateX(-50%) translateY(0); opacity: 1; }

  @media (max-width: 600px) {
    #toolbar { gap: 4px; padding: 8px 10px; }
    .btn { padding: 5px 10px; font-size: 12px; }
    #search { width: 33vw; }
    #modal { padding: 18px; }
  }
</style>
</head>
<body>

<!-- TOOLBAR -->
<div id="toolbar">
  <span class="brand">MASTERPLAN</span>
  <div class="sep"></div>
  <button class="btn primary" id="btn-add">Add Node</button>
  <button class="btn" id="btn-reset-layout">Relayout</button>
  <div id="bg-color-wrap" class="btn btn-icon" title="Canvas background colour">
    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <!-- Paint bucket icon -->
      <path d="M3 11.5a1 1 0 1 0 2 0 1 1 0 0 0-2 0Z" stroke="currentColor" stroke-width="1.3"/>
      <path d="M5.5 9.5 10 5l1.5 1.5-4.5 4.5H5.5V9.5Z" stroke="currentColor" stroke-width="1.3" stroke-linejoin="round"/>
      <path d="M10 5l1-1 1 1" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    <div id="bg-color-swatch"></div>
    <input type="color" id="bg-color-input" value="#0d0f14" title="Canvas background colour">
  </div>
  <button class="btn btn-icon" id="btn-shape-rect" title="Rectangular nodes">
    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect x="2" y="4" width="12" height="8" rx="1.5" stroke="currentColor" stroke-width="1.5"/>
    </svg>
  </button>
  <button class="btn btn-icon" id="btn-shape-outline" title="Circle nodes">
    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <circle cx="8" cy="8" r="5.5" stroke="currentColor" stroke-width="1.5"/>
    </svg>
  </button>
  <button class="btn btn-icon" id="btn-shape-reset" title="Reset shape">
    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M3 8a5 5 0 1 0 1.5-3.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
      <polyline points="1,4 4.5,4.5 4,1" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </button>
  <div class="sep"></div>
  <button class="btn" id="btn-save-ls">Save</button>
  <button class="btn" id="btn-load-ls">Load</button>
  <div class="sep"></div>
  <button class="btn" id="btn-import-json">Import JSON</button>
  <div id="export-wrap">
    <button class="btn" id="btn-export-menu">Export</button>
    <div id="export-panel">
      <button class="btn" id="export-svg">Export SVG</button>
      <button class="btn" id="export-json">Export JSON</button>
    </div>
  </div>
  <input type="file" id="file-input" accept=".json" style="display:none">
  <div class="sep"></div>
  <div id="search-wrap">
    <input type="text" id="search" placeholder="Search nodes…">
  </div>
</div>

<!-- CANVAS -->
<div id="canvas-wrap">
  <div id="empty-hint">
    <div class="big" style="font-size:28px;letter-spacing:3px;font-weight:700;color:#CCC">MASTERPLAN</div>
    <p>Your network is empty.<br>
    <strong>+ Add Node</strong> to begin, or <strong>Import JSON</strong> to load a saved graph.</p>
  </div>
  <!-- OVERLAY PANEL -->
  <button id="btn-overlay-toggle" title="Toggle overview panel">
    <svg width="10" height="14" viewBox="0 0 10 14" fill="none">
      <path id="overlay-chevron" d="M7 1L2 7L7 13" stroke="#555" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </button>
  <div id="overlay-panel">
    <div id="overlay-header">
      <span>Entry</span>
      <div class="col-labels">
        <span title="Importance">IMP</span>
        <span title="Connections">CNX</span>
      </div>
    </div>
    <div id="overlay-list"></div>
  </div>

  <button id="btn-zoom-fit" title="Zoom to fit">
    <svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
      <!-- Four corner brackets -->
      <path d="M2 6V2H6" stroke="#888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M12 2H16V6" stroke="#888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M16 12V16H12" stroke="#888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M6 16H2V12" stroke="#888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </button>
  <svg id="graph">
    <defs>
      <!-- Arrow marker — inherits color from stroke via context-stroke -->
      <marker id="arrow-link" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="userSpaceOnUse">
        <path d="M0,0.5 L0,5.5 L6,3 z" fill="context-stroke" opacity="0.7"/>
      </marker>
      <!-- Subtle base glow -->
      <filter id="glow-base" x="-40%" y="-40%" width="180%" height="180%">
        <feGaussianBlur stdDeviation="4" result="blur"/>
        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
      <!-- Bright hover glow -->
      <filter id="glow-bright" x="-60%" y="-60%" width="220%" height="220%">
        <feGaussianBlur stdDeviation="8" result="blur"/>
        <feComponentTransfer in="blur" result="bright">
          <feFuncR type="linear" slope="1.4"/>
          <feFuncG type="linear" slope="1.4"/>
          <feFuncB type="linear" slope="1.4"/>
        </feComponentTransfer>
        <feMerge><feMergeNode in="bright"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    </defs>
    <g id="zoom-layer">
      <g id="links-layer"></g>
      <g id="particles-layer"></g>
      <g id="nodes-layer"></g>
    </g>
  </svg>
</div>

<!-- STATUS BAR -->
<div id="statusbar">
  <span id="status-nodes">Nodes: 0</span>
  <span id="status-links">Links: 0</span>
  <span id="status-hint">Double-click or right-click a node to edit · Drag to reposition</span>
</div>

<!-- FOOTER -->
<div id="footer">
  <span class="footer-left">For personal use only.</span>
  <span class="footer-right">© Constantinos Tolias 2026. All rights reserved.</span>
  <span class="footer-version">v1.030</span>
</div>

<!-- TOOLTIP -->
<div id="tooltip"></div>

<!-- EXPORT PANEL -->
<!-- NOTIFICATION -->
<div id="notif"></div>

<!-- MODAL -->
<div id="modal-overlay">
  <div id="modal">
    <button id="modal-close">✕</button>
    <h2 id="modal-title">Edit Node</h2>

    <div class="field-group">
      <label>Name *</label>
      <input type="text" id="m-name" placeholder="Node name…" maxlength="40">
    </div>

    <div class="field-group">
      <label>Importance (1–10) — scales bubble size</label>
      <div class="range-row">
        <input type="range" id="m-importance" min="1" max="10" value="5">
        <span class="range-val" id="m-importance-val">5</span>
      </div>
    </div>

    <div class="field-group">
      <label>Bubble Colour</label>
      <div class="color-row">
        <input type="color" id="m-color" value="#95D5B2">
        <div class="color-presets" id="color-presets"></div>
      </div>
    </div>

    <div class="field-group">
      <label>Outgoing Links → (this node links TO)</label>
      <select id="m-links-out" class="link-select" multiple></select>
      <small style="color:var(--muted);font-size:11px;margin-top:3px;display:block">Hold Ctrl/Cmd to select multiple</small>
    </div>

    <div class="field-group">
      <label>Incoming Links ← (nodes that link TO this)</label>
      <select id="m-links-in" class="link-select" multiple></select>
    </div>

    <div class="field-group">
      <label>Notes / Description</label>
      <textarea id="m-notes" rows="2" placeholder="Optional description…" style="font-family:var(--font);font-size:12px;width:100%;padding:8px 12px;border:1px solid #2E2E2E;border-radius:6px;outline:none;background:#141414;color:#CCC;resize:vertical;"></textarea>
    </div>

    <div class="field-group">
      <label>Custom Properties</label>
      <div id="custom-props-list"></div>
      <button class="btn" id="btn-add-prop" style="margin-top:4px;font-size:12px">Add Property</button>
    </div>

    <div class="modal-actions">
      <button class="btn danger" id="btn-delete-node" style="margin-right:auto">Delete</button>
      <button class="btn" id="btn-cancel">Cancel</button>
      <button class="btn primary" id="btn-save-node">Save Node</button>
    </div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════
//  SUSTAINNET — Force-Directed Network Mapper
// ═══════════════════════════════════════════════════════════

const PASTEL_PRESETS = [
  '#95D5B2','#A8DADC','#BDE0FE','#CDB4DB',
  '#FFAFCC','#F4A261','#E9C46A','#F2CC8F',
  '#81B29A','#E76F51','#D4E09B','#A2C4C9'
];

const STORAGE_KEY = 'sustainnet_graph_v2';

// ── STATE ──
let nodes = [];
let links = [];
let simulation, svg, g, linkLayer, particleLayer, nodeLayer;
let hoveredNodeId = null;
const particleState = new Map(); // linkKey → [{t, speed, r}]
let editingNodeId = null;
let nodeShape = "circle"; // "circle" | "rect"
let overlayVisible = true;
let zoomTransform = d3.zoomIdentity;
let zoomBehavior;

// ── HELPERS ──
const uid = () => 'n' + Math.random().toString(36).substr(2,8);
const nodeRadius = imp => 10 + (imp - 1) * (50/9); // 10–60px radius (20–120px dia)

// Rect half-dimensions — width wider than height for a card feel
const nodeHalfW = imp => nodeRadius(imp) * 1.45;
const nodeHalfH = imp => nodeRadius(imp) * 0.85;

// Edge-intersection offset for straight lines hitting a rect from direction (dx,dy)
function rectEdgeOffset(imp, dx, dy) {
  const hw = nodeHalfW(imp), hh = nodeHalfH(imp);
  const adx = Math.abs(dx), ady = Math.abs(dy);
  // Which edge does the line hit? Compare slopes.
  if (adx * hh > ady * hw) {
    // Hits left or right edge
    return hw / adx;
  } else {
    // Hits top or bottom edge
    return hh / ady;
  }
}
const notify = (msg, dur=2200) => {
  const el = document.getElementById('notif');
  el.textContent = msg;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), dur);
};

// ── SAMPLE DATA ──
function loadSampleData() {
  nodes = [
    { id: uid(), name: 'Passive Solar Design', importance: 8, color: '#95D5B2', notes: 'Core bioclimatic strategy', linksOut: [], linksIn: [], custom: [] },
    { id: uid(), name: 'Material Lifecycle', importance: 6, color: '#A8DADC', notes: 'Cradle-to-cradle assessment', linksOut: [], linksIn: [], custom: [{key:'Standard',val:'ISO 14040'}] },
    { id: uid(), name: 'Water Harvesting', importance: 7, color: '#BDE0FE', notes: 'Greywater + rainwater systems', linksOut: [], linksIn: [], custom: [] },
    { id: uid(), name: 'Urban Biodiversity', importance: 5, color: '#D4E09B', notes: 'Green corridors & habitat', linksOut: [], linksIn: [], custom: [] },
    { id: uid(), name: 'Net-Zero Energy', importance: 9, color: '#F2CC8F', notes: 'Renewables + demand reduction', linksOut: [], linksIn: [], custom: [{key:'Target Year',val:'2030'}] },
  ];
  // Define some links
  nodes[0].linksOut = [nodes[4].id];
  nodes[1].linksOut = [nodes[0].id, nodes[2].id];
  nodes[3].linksOut = [nodes[2].id];
  nodes[4].linksOut = [nodes[2].id];
  rebuildLinks();
}

function rebuildLinks() {
  links = [];
  nodes.forEach(n => {
    (n.linksOut || []).forEach(tid => {
      if (nodes.find(x => x.id === tid)) {
        links.push({ source: n.id, target: tid });
      }
    });
  });
  // sync linksIn
  nodes.forEach(n => { n.linksIn = []; });
  links.forEach(l => {
    const t = nodes.find(x => x.id === (typeof l.target === 'object' ? l.target.id : l.target));
    const s = l.source;
    const sid = typeof s === 'object' ? s.id : s;
    if (t) { if (!t.linksIn.includes(sid)) t.linksIn.push(sid); }
  });
}

// ══════════════════════════════════════════════════════
//  D3 GRAPH SETUP
// ══════════════════════════════════════════════════════
function initGraph() {
  svg = d3.select('#graph');
  g = d3.select('#zoom-layer');
  linkLayer = d3.select('#links-layer');
  particleLayer = d3.select('#particles-layer');
  nodeLayer = d3.select('#nodes-layer');

  zoomBehavior = d3.zoom()
    .scaleExtent([0.1, 4])
    .on('zoom', (e) => {
      zoomTransform = e.transform;
      g.attr('transform', e.transform);
    });
  svg.call(zoomBehavior);

  // Center on init
  const W = svg.node().clientWidth, H = svg.node().clientHeight;
  svg.call(zoomBehavior.transform, d3.zoomIdentity.translate(W/2, H/2));

  simulation = d3.forceSimulation()
    .force('link', d3.forceLink().id(d => d.id).distance(d => {
      const s = nodes.find(n => n.id === (typeof d.source === 'object' ? d.source.id : d.source));
      const t = nodes.find(n => n.id === (typeof d.target === 'object' ? d.target.id : d.target));
      // Use the MINIMUM importance of the pair so low-importance connections stay short
      const minImp = s && t ? Math.min(s.importance, t.importance) : 5;
      return 40 + minImp * 18;
    }).strength(0.4))
    .force('charge', d3.forceManyBody().strength(d => -180 - d.importance * 30))
    .force('collision', d3.forceCollide().radius(d => nodeRadius(d.importance) + 18).strength(0.85))
    .force('center', d3.forceCenter(0, 0))
    .on('tick', ticked);
}

function linkCoords(d) {
  const sx = d.source.x, sy = d.source.y;
  const tx = d.target.x, ty = d.target.y;
  const dx = tx - sx, dy = ty - sy;
  const dist = Math.sqrt(dx*dx + dy*dy) || 1;
  const ndx = dx / dist, ndy = dy / dist;
  let startX, startY, endX, endY;
  if (nodeShape === 'rect') {
    const st = rectEdgeOffset(d.source.importance || 5, ndx, ndy);
    startX = sx + ndx * st; startY = sy + ndy * st;
    const tt = rectEdgeOffset(d.target.importance || 5, ndx, ndy);
    endX = tx - ndx * (tt + 8); endY = ty - ndy * (tt + 8);
  } else {
    const sr = nodeRadius(d.source.importance || 5);
    const tr = nodeRadius(d.target.importance || 5);
    startX = sx + ndx * sr; startY = sy + ndy * sr;
    endX   = tx - ndx * (tr + 8); endY = ty - ndy * (tr + 8);
  }
  return { startX, startY, endX, endY };
}

function ticked() {
  // ── Link paths ──
  linkLayer.selectAll('.link-path').attr('d', d => {
    const { startX, startY, endX, endY } = linkCoords(d);
    return `M${startX},${startY} L${endX},${endY}`;
  });

  // ── Particles ──
  links.forEach(d => {
    const sid = typeof d.source === 'object' ? d.source.id : d.source;
    const tid = typeof d.target === 'object' ? d.target.id : d.target;
    const key = sid + '->' + tid;
    if (!particleState.has(key)) {
      // Create 2 particles per link staggered
      const sNode = nodes.find(n => n.id === sid);
      const speed = 0.004 + (sNode ? sNode.importance * 0.0003 : 0);
      particleState.set(key, [
        { t: 0,    speed },
        { t: 0.5,  speed },
      ]);
    }
    const ps = particleState.get(key);
    ps.forEach(p => { p.t += p.speed; if (p.t > 1) p.t -= 1; });
  });

  // Remove stale particle states
  const activeKeys = new Set(links.map(d => {
    const sid = typeof d.source === 'object' ? d.source.id : d.source;
    const tid = typeof d.target === 'object' ? d.target.id : d.target;
    return sid + '->' + tid;
  }));
  for (const k of particleState.keys()) {
    if (!activeKeys.has(k)) particleState.delete(k);
  }

  // Render particles
  const allParticles = [];
  links.forEach(d => {
    const sid = typeof d.source === 'object' ? d.source.id : d.source;
    const tid = typeof d.target === 'object' ? d.target.id : d.target;
    const key = sid + '->' + tid;
    const ps = particleState.get(key);
    if (!ps) return;
    const { startX, startY, endX, endY } = linkCoords(d);
    const sNode = nodes.find(n => n.id === sid);
    const color = sNode ? sNode.color || '#74C69D' : '#74C69D';
    ps.forEach(p => {
      allParticles.push({
        x: startX + (endX - startX) * p.t,
        y: startY + (endY - startY) * p.t,
        r: 2.5,
        color,
        key
      });
    });
  });

  const pSel = particleLayer.selectAll('.particle').data(allParticles, (d,i) => i);
  pSel.enter().append('circle').attr('class', 'particle')
    .merge(pSel)
    .attr('cx', d => d.x)
    .attr('cy', d => d.y)
    .attr('r', d => d.r)
    .attr('fill', d => d.color)
    .attr('opacity', 0.75)
    .attr('pointer-events', 'none');
  pSel.exit().remove();

  // ── Node positions ──
  nodeLayer.selectAll('.node-group')
    .attr('transform', d => `translate(${d.x},${d.y})`);

  // ── Hover highlight ──
  if (hoveredNodeId) {
    const neighborIds = new Set();
    links.forEach(d => {
      const sid = typeof d.source === 'object' ? d.source.id : d.source;
      const tid = typeof d.target === 'object' ? d.target.id : d.target;
      if (sid === hoveredNodeId) neighborIds.add(tid);
      if (tid === hoveredNodeId) neighborIds.add(sid);
    });
    neighborIds.add(hoveredNodeId);

    nodeLayer.selectAll('.node-group').each(function(d) {
      const grp = d3.select(this);
      const isHighlighted = neighborIds.has(d.id);
      grp.classed('highlighted', isHighlighted)
         .classed('dimmed', !isHighlighted);
    });

    linkLayer.selectAll('.link-path').each(function(d) {
      const sid = typeof d.source === 'object' ? d.source.id : d.source;
      const tid = typeof d.target === 'object' ? d.target.id : d.target;
      const connected = sid === hoveredNodeId || tid === hoveredNodeId;
      d3.select(this)
        .attr('stroke-opacity', connected ? 0.9 : 0.05)
        .attr('stroke-width', connected ? 1.5 : 1);
    });

    particleLayer.selectAll('.particle')
      .attr('opacity', p => { const [s,t] = (p.key||'').split('->'); return (neighborIds.has(s)||neighborIds.has(t)) ? 0.9 : 0.06; });
  } else {
    nodeLayer.selectAll('.node-group')
      .classed('highlighted', false).classed('dimmed', false);
    linkLayer.selectAll('.link-path')
      .attr('stroke-opacity', 0.35)
      .attr('stroke-width', 1);
    particleLayer.selectAll('.particle').attr('opacity', 0.75);
  }
}

function updateGraph(animate = false) {
  rebuildLinks();
  updateStatus();
  updateEmptyHint();
  autoSave();

  // ── LINKS ──
  const linkData = linkLayer.selectAll('.link-path').data(links, d => {
    const sid = typeof d.source === 'object' ? d.source.id : d.source;
    const tid = typeof d.target === 'object' ? d.target.id : d.target;
    return sid + '->' + tid;
  });

  linkData.join(
    enter => enter.append('path')
      .attr('class', 'link-path')
      .style('opacity', 0)
      .call(el => {
        updateLinkStyle(el);
        el.transition().duration(500).style('opacity', 1);
      }),
    update => update.call(updateLinkStyle),
    exit => exit.transition().duration(300).style('opacity',0).remove()
  );

  // ── NODES ──
  const nodeData = nodeLayer.selectAll('.node-group').data(nodes, d => d.id);

  nodeData.join(
    enter => {
      const grp = enter.append('g').attr('class', 'node-group')
        .attr('transform', d => `translate(${d.x||0},${d.y||0})`)
        .call(d3.drag()
          .on('start', dragStart)
          .on('drag', dragged)
          .on('end', dragEnd))
        .on('dblclick', (e,d) => { e.preventDefault(); openModal(d.id); })
        .on('contextmenu', (e,d) => { e.preventDefault(); openModal(d.id); })
        .on('mouseenter', (e, d) => { hoveredNodeId = d.id; showTooltip(e, d); })
        .on('mousemove', moveTooltip)
        .on('mouseleave', (e, d) => { hoveredNodeId = null; hideTooltip(); });

      grp.append('circle')
        .attr('class', 'node-circle')
        .attr('r', 0)
        .transition().duration(600)
        .ease(d3.easeElastic.period(0.5))
        .attr('r', d => nodeRadius(d.importance));

      const textEl = grp.append('text')
        .attr('class', 'node-label')
        .style('opacity', 0);

      updateNodeStyle(grp);
      updateNodeLabels(grp);

      // Fade in text after labels are populated
      textEl.transition().duration(400).style('opacity', 1);

      return grp;
    },
    update => {
      update.select('.node-circle')
        .transition().duration(400).ease(d3.easeElastic.period(0.6))
        .attr('r', d => nodeRadius(d.importance));
      updateNodeStyle(update);
      updateNodeLabels(update);
      return update;
    },
    exit => exit.select('.node-circle')
      .transition().duration(300).ease(d3.easeBackIn.overshoot(2))
      .attr('r', 0)
      .selection().transition().duration(0).remove()
  );

  // Restart simulation
  simulation.nodes(nodes);
  simulation.force('link').links(links);
  simulation.alpha(animate ? 0.8 : 0.3).restart();
}

function computeFontCaps() {
  // Build a global font-size ceiling per importance level (1–10).
  // Strategy: for each importance tier, find the largest font size that fits
  // *at least one word* inside that tier's node radius.
  // This guarantees strict hierarchy: a higher-importance node always has
  // an equal or larger cap than any lower-importance node.
  const caps = {}; // importance (int) → max allowed fontSize
  for (let imp = 1; imp <= 10; imp++) {
    const r = nodeRadius(imp);
    const usableW = r * 1.44;
    // Largest font where even a single 3-char word fits (conservative floor)
    for (let fs = 14; fs >= 7; fs--) {
      const charW = fs * 0.62;
      if (Math.floor(usableW / charW) >= 3) { caps[imp] = fs; break; }
    }
    if (!caps[imp]) caps[imp] = 7;
  }
  return caps;
}

function updateNodeLabels(sel) {
  // Compute importance-ordered font caps once for this render pass
  const fontCaps = computeFontCaps();

  sel.each(function(d) {
    const r = nodeRadius(d.importance);
    const textEl = d3.select(this).select('text.node-label').node();
    if (!textEl) return;

    while (textEl.firstChild) textEl.removeChild(textEl.firstChild);

    textEl.setAttribute('font-family', "'Space Mono', 'Courier New', monospace");
    textEl.setAttribute('fill', '#FFFFFF');

    const words = d.name.split(' ');
    const maxLines = 4;

    // The font ceiling for this node's importance tier.
    // A lower-importance node will never exceed the cap of a higher-importance one.
    const ceiling = fontCaps[d.importance] || 7;

    let fontSize = ceiling;
    let lines = [];

    for (fontSize = ceiling; fontSize >= 7; fontSize--) {
      const charW   = fontSize * 0.62; // Space Mono fixed-width
      const usableW = nodeShape === 'rect' ? nodeHalfW(d.importance) * 1.8 : r * 1.44;
      const maxCharsPerLine = Math.max(3, Math.floor(usableW / charW));

      lines = [];
      let cur = '';
      let fits = true;

      for (const word of words) {
        if (word.length > maxCharsPerLine) { fits = false; break; }
        const test = cur ? cur + ' ' + word : word;
        if (test.length <= maxCharsPerLine) {
          cur = test;
        } else {
          lines.push(cur);
          cur = word;
        }
      }
      if (!fits) continue;
      if (cur) lines.push(cur);
      if (lines.length <= maxLines) break;
    }

    if (lines.length === 0) lines = [d.name];
    fontSize = Math.max(7, fontSize);
    textEl.setAttribute('font-size', fontSize);

    const lh = fontSize * 1.3;
    const startDy = -((lines.length - 1) * lh) / 2;

    lines.forEach((line, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.setAttribute('x', '0');
      tspan.setAttribute('dy', i === 0 ? `${startDy}px` : `${lh}px`);
      tspan.textContent = line;
      textEl.appendChild(tspan);
    });
  });
}



function updateNodeStyle(sel) {
  sel.select('.node-circle')
    .attr('fill', d => nodeShape === 'outline' ? 'rgba(255,255,255,0.1)' : (d.color || '#95D5B2'))
    .attr('stroke', d => d.color || '#95D5B2')
    .attr('stroke-width', d => nodeShape === 'outline'
      ? 2 + d.importance * 0.18
      : 1.5 + d.importance * 0.1)
    .attr('filter', 'url(#glow-base)');
  // Ensure rect geometry is correct after data updates
  if (nodeShape === 'rect') {
    sel.select('.node-circle')
      .attr('x', d => -nodeHalfW(d.importance))
      .attr('y', d => -nodeHalfH(d.importance))
      .attr('width', d => nodeHalfW(d.importance) * 2)
      .attr('height', d => nodeHalfH(d.importance) * 2)
      .attr('rx', 6).attr('ry', 6);
  }
}

// ── SHAPE MORPH ──
// Replaces the shape element inside every node-group with the correct tag,
// then re-applies geometry and style. Called on shape toggle.
function applyNodeShape(shape) {
  nodeShape = shape;

  nodeLayer.selectAll('.node-group').each(function(d) {
    const grp = d3.select(this);
    // Remove existing shape element
    grp.select('.node-circle').remove();

    const r  = nodeRadius(d.importance);
    const hw = nodeHalfW(d.importance);
    const hh = nodeHalfH(d.importance);

    let shapeEl;
    if (shape === 'rect') {
      shapeEl = grp.insert('rect', 'text') // insert before the label text
        .attr('class', 'node-circle')
        .attr('x', -hw).attr('y', -hh)
        .attr('width', hw * 2).attr('height', hh * 2)
        .attr('rx', 6).attr('ry', 6)
        .style('opacity', 0);
    } else {
      shapeEl = grp.insert('circle', 'text')
        .attr('class', 'node-circle')
        .attr('r', 0)
        .style('opacity', 0);
    }

    // Animate in
    if (shape === 'rect') {
      shapeEl.transition().duration(450).ease(d3.easeCubicOut)
        .style('opacity', 1)
        .attr('x', -hw).attr('y', -hh)
        .attr('width', hw * 2).attr('height', hh * 2);
    } else {
      shapeEl.transition().duration(450).ease(d3.easeElastic.period(0.55))
        .style('opacity', 1)
        .attr('r', r);
    }

    // Apply fill/stroke — 'outline' mode: no fill, colored stroke only
    if (shape === 'outline') {
      shapeEl
        .attr('fill', 'rgba(255,255,255,0.8)')
        .attr('stroke', d.color || '#95D5B2')
        .attr('stroke-width', 2 + d.importance * 0.15);
    } else {
      shapeEl
        .attr('fill', d.color || '#95D5B2')
        .attr('stroke', d3.color(d.color || '#95D5B2').brighter(0.3))
        .attr('stroke-width', 1.5 + d.importance * 0.1);
    }
  });

  // Re-run labels with updated shape context
  updateNodeLabels(nodeLayer.selectAll('.node-group'));

  // Update collision radius for rects (use half-diagonal as approximation)
  simulation.force('collision',
    d3.forceCollide()
      .radius(d => (shape === 'rect'
        ? Math.sqrt(nodeHalfW(d.importance)**2 + nodeHalfH(d.importance)**2)
        : nodeRadius(d.importance)) + 12)
      .strength(0.85)
  );
  simulation.alpha(0.15).restart();
}

function updateLinkStyle(sel) {
  sel
    .attr('stroke', d => {
      const sid = typeof d.source === 'object' ? d.source.id : d.source;
      const sNode = nodes.find(n => n.id === sid);
      return sNode ? sNode.color || '#74C69D' : '#74C69D';
    })
    .attr('stroke-width', 1)
    .attr('stroke-opacity', 0.35)
    .attr('marker-end', 'url(#arrow-link)');
}

function dragStart(e, d) {
  if (!e.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x; d.fy = d.y;
  d3.select(this).select('.node-circle')
    .transition().duration(200)
    .attr('stroke-width', 3 + d.importance * 0.15);
}
function dragged(e, d) { d.fx = e.x; d.fy = e.y; }
function dragEnd(e, d) {
  if (!e.active) simulation.alphaTarget(0);
  d.fx = null; d.fy = null;
  d3.select(this).select('.node-circle')
    .transition().duration(200)
    .attr('stroke-width', 1.5 + d.importance * 0.1);
}

// ── TOOLTIP ──
function showTooltip(e, d) {
  const tip = document.getElementById('tooltip');
  let html = `<strong>${d.name}</strong>`;
  html += `Importance: ${d.importance}/10`;
  if (d.notes) html += `<br><span style="opacity:0.7">${d.notes}</span>`;
  const outNames = (d.linksOut||[]).map(id => { const n = nodes.find(x=>x.id===id); return n ? n.name : ''; }).filter(Boolean);
  if (outNames.length) html += `<br>→ ${outNames.join(', ')}`;
  (d.custom||[]).forEach(c => { if (c.key) html += `<br>${c.key}: ${c.val}`; });
  tip.innerHTML = html;
  tip.classList.add('show');
}
function moveTooltip(e) {
  const tip = document.getElementById('tooltip');
  tip.style.left = (e.clientX + 14) + 'px';
  tip.style.top = (e.clientY - 10) + 'px';
}
function hideTooltip() {
  document.getElementById('tooltip').classList.remove('show');
}

// ── SEARCH / FILTER ──
document.getElementById('search').addEventListener('input', function() {
  const q = this.value.toLowerCase().trim();
  if (!q) {
    nodeLayer.selectAll('.node-group').classed('dimmed', false);
    linkLayer.selectAll('.link-path').classed('dimmed', false);
    return;
  }
  nodeLayer.selectAll('.node-group').classed('dimmed', d => !d.name.toLowerCase().includes(q));
  linkLayer.selectAll('.link-path').classed('dimmed', d => {
    const sid = typeof d.source === 'object' ? d.source.id : d.source;
    const tid = typeof d.target === 'object' ? d.target.id : d.target;
    const sn = nodes.find(n=>n.id===sid), tn = nodes.find(n=>n.id===tid);
    return !(sn && sn.name.toLowerCase().includes(q)) && !(tn && tn.name.toLowerCase().includes(q));
  });
});

// ══════════════════════════════════════════════════════
//  MODAL
// ══════════════════════════════════════════════════════
function openModal(nodeId) {
  hideTooltip();
  editingNodeId = nodeId;
  const node = nodes.find(n => n.id === nodeId);
  const isNew = !node;
  const n = node || { id: nodeId, name: '', importance: 5, color: PASTEL_PRESETS[0], linksOut: [], linksIn: [], notes: '', custom: [] };

  document.getElementById('modal-title').textContent = isNew ? 'Add Node' : 'Edit Node';
  document.getElementById('m-name').value = n.name;
  document.getElementById('m-importance').value = n.importance;
  document.getElementById('m-importance-val').textContent = n.importance;
  document.getElementById('m-color').value = n.color;
  document.getElementById('m-notes').value = n.notes || '';

  // Color presets
  const presetsEl = document.getElementById('color-presets');
  presetsEl.innerHTML = '';
  PASTEL_PRESETS.forEach(c => {
    const div = document.createElement('div');
    div.className = 'color-preset';
    div.style.background = c;
    div.title = c;
    div.onclick = () => { document.getElementById('m-color').value = c; };
    presetsEl.appendChild(div);
  });

  // Link selects
  const others = nodes.filter(x => x.id !== nodeId);
  const fillSelect = (selId, selectedIds) => {
    const sel = document.getElementById(selId);
    sel.innerHTML = '';
    // Null / no-connection sentinel option
    const nullOpt = document.createElement('option');
    nullOpt.value = '__none__';
    nullOpt.textContent = '— none —';
    nullOpt.style.color = '#AAAAAA';
    nullOpt.style.fontStyle = 'italic';
    nullOpt.selected = !(selectedIds && selectedIds.length > 0);
    sel.appendChild(nullOpt);
    others.forEach(o => {
      const opt = document.createElement('option');
      opt.value = o.id;
      opt.textContent = o.name || '(unnamed)';
      opt.selected = (selectedIds||[]).includes(o.id);
      sel.appendChild(opt);
    });
  };
  fillSelect('m-links-out', n.linksOut);
  fillSelect('m-links-in', n.linksIn);

  // Custom props
  const cpl = document.getElementById('custom-props-list');
  cpl.innerHTML = '';
  (n.custom||[]).forEach(c => addCustomPropRow(c.key, c.val));

  document.getElementById('btn-delete-node').style.display = isNew ? 'none' : 'inline-flex';

  document.getElementById('modal-overlay').classList.add('show');
  setTimeout(() => document.getElementById('m-name').focus(), 100);
}

function addCustomPropRow(key='', val='') {
  const row = document.createElement('div');
  row.className = 'custom-prop-row';
  row.innerHTML = `
    <input type="text" placeholder="Property name" value="${key}" style="flex:1;font-family:var(--font);font-size:13px;padding:6px 10px;border:1px solid #2E2E2E;border-radius:4px;background:#141414;color:#CCC;outline:none;">
    <input type="text" placeholder="Value" value="${val}" style="flex:1;font-family:var(--font);font-size:13px;padding:6px 10px;border:1px solid #2E2E2E;border-radius:4px;background:#141414;color:#CCC;outline:none;">
    <button class="rm-prop" title="Remove">✕</button>
  `;
  row.querySelector('.rm-prop').onclick = () => {
    gsap.to(row, { height: 0, opacity: 0, marginBottom: 0, duration: 0.2, onComplete: () => row.remove() });
  };
  document.getElementById('custom-props-list').appendChild(row);
  gsap.from(row, { opacity: 0, y: -8, duration: 0.25, ease: 'back.out(2)' });
}

function closeModal() {
  document.getElementById('modal-overlay').classList.remove('show');
  editingNodeId = null;
}

function saveNode() {
  const name = document.getElementById('m-name').value.trim();
  if (!name) { document.getElementById('m-name').style.borderColor='#E74C3C'; document.getElementById('m-name').focus(); return; }
  document.getElementById('m-name').style.borderColor='';

  const importance = +document.getElementById('m-importance').value;
  const color = document.getElementById('m-color').value;
  const notes = document.getElementById('m-notes').value.trim();

  const selOut = [...document.getElementById('m-links-out').selectedOptions].map(o=>o.value).filter(v => v && v !== '__none__');
  const selIn = [...document.getElementById('m-links-in').selectedOptions].map(o=>o.value).filter(v => v && v !== '__none__');

  const custom = [];
  document.querySelectorAll('#custom-props-list .custom-prop-row').forEach(row => {
    const inputs = row.querySelectorAll('input');
    if (inputs[0].value.trim()) custom.push({ key: inputs[0].value.trim(), val: inputs[1].value.trim() });
  });

  const existing = nodes.find(n => n.id === editingNodeId);
  if (existing) {
    Object.assign(existing, { name, importance, color, notes, linksOut: selOut, custom });
  } else {
    nodes.push({ id: editingNodeId, name, importance, color, notes, linksOut: selOut, linksIn: [], custom, x: 0, y: 0 });
  }

  // Handle incoming links: update other nodes' linksOut
  nodes.forEach(n => {
    if (n.id === editingNodeId) return;
    const wasLinked = n.linksOut.includes(editingNodeId);
    const shouldLink = selIn.includes(n.id);
    if (shouldLink && !wasLinked) n.linksOut.push(editingNodeId);
    if (!shouldLink && wasLinked) n.linksOut = n.linksOut.filter(id => id !== editingNodeId);
  });

  closeModal();
  updateGraph(true);
  notify(`✓ Node "${name}" saved`);
}

document.getElementById('btn-save-node').onclick = saveNode;
document.getElementById('btn-cancel').onclick = closeModal;
document.getElementById('modal-close').onclick = closeModal;
document.getElementById('btn-delete-node').onclick = () => {
  const n = nodes.find(x=>x.id===editingNodeId);
  if (!n) return;
  if (!confirm(`Delete "${n.name}"?`)) return;
  nodes = nodes.filter(x => x.id !== editingNodeId);
  nodes.forEach(x => { x.linksOut = (x.linksOut||[]).filter(id=>id!==editingNodeId); });
  closeModal();
  updateGraph(true);
  notify('Node deleted');
};
document.getElementById('modal-overlay').addEventListener('click', e => { if (e.target === document.getElementById('modal-overlay')) closeModal(); });
document.getElementById('m-importance').addEventListener('input', function() {
  document.getElementById('m-importance-val').textContent = this.value;
});
document.getElementById('btn-add-prop').onclick = () => addCustomPropRow();

// Mutual exclusion: selecting a real node deselects '-- none --', and vice-versa
['m-links-out','m-links-in'].forEach(id => {
  document.getElementById(id).addEventListener('change', function() {
    const opts = [...this.options];
    const noneOpt = opts.find(o => o.value === '__none__');
    if (!noneOpt) return;
    const anyRealSelected = opts.filter(o => o.value !== '__none__' && o.selected).length > 0;
    if (anyRealSelected) {
      noneOpt.selected = false;
    } else {
      // If user deselected everything, re-select none
      noneOpt.selected = true;
    }
  });
});

// ── ADD NODE ──
document.getElementById('btn-add').onclick = () => {
  const newId = uid();
  openModal(newId);
};

// ── RELAYOUT ──
// ── CANVAS BACKGROUND COLOUR ──
const bgColorInput = document.getElementById('bg-color-input');
const bgSwatch     = document.getElementById('bg-color-swatch');

function setCanvasBg(color) {
  document.documentElement.style.setProperty('--canvas-bg', color);
  bgSwatch.style.background = color;
  bgColorInput.value = color;
}
// Set initial swatch to match dark default
setCanvasBg('#0d0f14');

bgColorInput.addEventListener('input', (e) => setCanvasBg(e.target.value));
bgColorInput.addEventListener('change', (e) => setCanvasBg(e.target.value));

document.getElementById('btn-reset-layout').onclick = () => {
  nodes.forEach(n => { n.x = (Math.random()-0.5)*200; n.y = (Math.random()-0.5)*200; n.vx=0; n.vy=0; });
  simulation.alpha(1).restart();
  notify('Layout reset');
};

// ── NODE SHAPE TOGGLE ──
document.getElementById('btn-shape-rect').onclick = () => {
  if (nodeShape === 'rect') return;
  applyNodeShape('rect');
  notify('Rectangular nodes');
};

document.getElementById('btn-shape-outline').onclick = () => {
  if (nodeShape === 'outline') return;
  applyNodeShape('outline');
  notify('Outline nodes');
};

document.getElementById('btn-shape-reset').onclick = () => {
  if (nodeShape === 'circle') return;
  applyNodeShape('circle');
  notify('Circular nodes');
};


// ── ZOOM TO FIT ──
function zoomToFit() {
  if (!nodes.length || !zoomBehavior) return;
  const svgEl = svg.node();
  const W = svgEl.clientWidth, H = svgEl.clientHeight;
  const padding = 60;

  // Compute bounding box of all nodes
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  nodes.forEach(n => {
    const r = nodeRadius(n.importance);
    minX = Math.min(minX, n.x - r);
    minY = Math.min(minY, n.y - r);
    maxX = Math.max(maxX, n.x + r);
    maxY = Math.max(maxY, n.y + r);
  });

  const bw = maxX - minX, bh = maxY - minY;
  const scale = Math.min(0.9, (W - padding * 2) / bw, (H - padding * 2) / bh);
  const tx = W / 2 - scale * (minX + bw / 2);
  const ty = H / 2 - scale * (minY + bh / 2);

  svg.transition().duration(500).ease(d3.easeCubicInOut)
    .call(zoomBehavior.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

document.getElementById('btn-zoom-fit').onclick = zoomToFit;

// ══════════════════════════════════════════════════════
//  PERSISTENCE
// ══════════════════════════════════════════════════════
function graphToJSON() {
  return JSON.stringify({ nodes: nodes.map(n => ({...n, x: n.x||0, y: n.y||0, vx:0, vy:0, fx:null, fy:null})), links: [] }, null, 2);
}

function loadFromJSON(json) {
  const data = typeof json === 'string' ? JSON.parse(json) : json;
  nodes = data.nodes || [];
  nodes.forEach(n => {
    n.linksOut = n.linksOut || [];
    n.linksIn = n.linksIn || [];
    n.custom = n.custom || [];
    n.x = n.x || (Math.random()-0.5)*300;
    n.y = n.y || (Math.random()-0.5)*300;
  });
  updateGraph(true);
}

function autoSave() {
  localStorage.setItem(STORAGE_KEY, graphToJSON());
}

document.getElementById('btn-save-ls').onclick = () => {
  autoSave();
  notify('Saved to browser');
};
document.getElementById('btn-load-ls').onclick = () => {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) { notify('⚠ Nothing saved yet'); return; }
  loadFromJSON(raw);
  notify('Loaded from browser');
};

// ── JSON IMPORT ──
document.getElementById('btn-import-json').onclick = () => document.getElementById('file-input').click();
document.getElementById('file-input').onchange = function() {
  const file = this.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    try { loadFromJSON(e.target.result); notify('↑ Imported ' + file.name); }
    catch(err) { alert('Invalid JSON: ' + err.message); }
  };
  reader.readAsText(file);
  this.value = '';
};

// Drag-drop import
document.getElementById('canvas-wrap').addEventListener('dragover', e => e.preventDefault());
document.getElementById('canvas-wrap').addEventListener('drop', e => {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (!file || !file.name.endsWith('.json')) return;
  const reader = new FileReader();
  reader.onload = ev => { try { loadFromJSON(ev.target.result); notify('↑ Dropped ' + file.name); } catch(err) { alert('Invalid JSON'); } };
  reader.readAsText(file);
});

// ── EXPORT PANEL ──
const exportPanel = document.getElementById('export-panel');
const exportWrap  = document.getElementById('export-wrap');

document.getElementById('btn-export-menu').onclick = (e) => {
  e.stopPropagation();
  exportPanel.classList.toggle('show');
};
// Close when clicking outside the export wrap
document.addEventListener('click', (e) => {
  if (!exportWrap.contains(e.target)) exportPanel.classList.remove('show');
});

document.getElementById('export-json').onclick = (e) => {
  e.stopPropagation();
  exportPanel.classList.remove('show');
  const blob = new Blob([graphToJSON()], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'masterplan-graph.json';
  a.click();
  notify('JSON exported');
};

document.getElementById('export-svg').onclick = (e) => {
  e.stopPropagation();
  exportPanel.classList.remove('show');
  const svgEl = document.getElementById('graph');
  const serializer = new XMLSerializer();
  let svgStr = serializer.serializeToString(svgEl);
  svgStr = svgStr.replace('<svg', `<svg style="background:${getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg').trim() || '#0d0f14'}"`);
  const blob = new Blob([svgStr], {type:'image/svg+xml'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'masterplan-graph.svg';
  a.click();
  notify('SVG exported');
};

// ── STATUS & EMPTY HINT ──
function updateStatus() {
  document.getElementById('status-nodes').textContent = `Nodes: ${nodes.length}`;
  document.getElementById('status-links').textContent = `Links: ${links.length}`;
  updateOverlay();
}

function updateOverlay() {
  const list = document.getElementById('overlay-list');
  if (!list) return;
  list.innerHTML = '';

  // Sort by importance desc, then name asc
  const sorted = [...nodes].sort((a, b) => {
    const scoreA = a.importance + (a.linksOut||[]).length + (a.linksIn||[]).length;
    const scoreB = b.importance + (b.linksOut||[]).length + (b.linksIn||[]).length;
    return scoreB - scoreA || a.name.localeCompare(b.name);
  });

  sorted.forEach(n => {
    const totalConn = ((n.linksOut || []).length + (n.linksIn || []).length);
    const row = document.createElement('div');
    row.className = 'overlay-row';
    row.innerHTML = `
      <div class="overlay-dot" style="background:${n.color || '#95D5B2'}"></div>
      <span class="overlay-name" title="${n.name}">${n.name}</span>
      <span class="overlay-imp">${n.importance}</span>
      <span class="overlay-conn">${totalConn}</span>
    `;
    row.onclick = () => openModal(n.id);
    list.appendChild(row);
  });

  // Show panel only if there are nodes
  const panel = document.getElementById('overlay-panel');
  const toggle = document.getElementById('btn-overlay-toggle');
  if (nodes.length > 0 && overlayVisible) {
    panel.classList.add('visible');
    toggle.style.right = (window.innerWidth * 0.33) + 'px';
  } else {
    panel.classList.remove('visible');
    toggle.style.right = '0';
  }
}
function updateEmptyHint() {
  document.getElementById('empty-hint').style.opacity = nodes.length === 0 ? '1' : '0';
  document.getElementById('empty-hint').style.pointerEvents = nodes.length === 0 ? 'auto' : 'none';
}

// ══════════════════════════════════════════════════════
//  INIT
// ══════════════════════════════════════════════════════
// ── OVERLAY TOGGLE ──
document.getElementById('btn-overlay-toggle').onclick = () => {
  overlayVisible = !overlayVisible;
  const panel = document.getElementById('overlay-panel');
  const toggle = document.getElementById('btn-overlay-toggle');
  const chevron = document.getElementById('overlay-chevron');
  if (overlayVisible) {
    panel.classList.add('visible');
    toggle.style.right = (window.innerWidth * 0.33) + 'px';
    chevron.setAttribute('d', 'M7 1L2 7L7 13'); // points left (close)
  } else {
    panel.classList.remove('visible');
    toggle.style.right = '0';
    chevron.setAttribute('d', 'M3 1L8 7L3 13'); // points right (open)
  }
};

window.addEventListener('load', () => {
  initGraph();

  // Start with empty canvas
  updateGraph(false);
});

window.addEventListener('resize', () => {
  if (simulation) simulation.force('center', d3.forceCenter(0,0)).alpha(0.1).restart();
});
</script>
</body>
</html>
